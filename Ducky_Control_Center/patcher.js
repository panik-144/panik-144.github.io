/**
 * Client-Side Binary Patcher
 * Replaces placeholder strings/bytes in a binary file with new values.
 */

const Patcher = {
    /**
     * Patches a binary buffer by replacing occurrences of a placeholder string with a new string.
     * @param {ArrayBuffer} buffer - The binary file content.
     * @param {string} placeholderIp - The IP to find (e.g., "111.111.111.111").
     * @param {string} newIp - The new IP to inject (e.g., "192.168.1.50").
     * @param {string} oldPort - The port to find (e.g., "4444").
     * @param {string} newPort - The new port to inject (e.g., "8080").
     * @returns {Blob} - The patched file as a Blob.
     */
    patch: function (buffer, placeholderIp, newIp, oldPort, newPort) {
        console.log(`[Patcher] Starting patch job...`);
        console.log(`[Patcher] Replacing IP: ${placeholderIp} -> ${newIp}`);
        console.log(`[Patcher] Replacing Port: ${oldPort} -> ${newPort}`);

        // Convert buffer to Uint8Array for manipulation
        let data = new Uint8Array(buffer);

        // 1. Patch IP
        // We need to be careful. If the binary stores IP as a string (common in reverse_tcp shellcode generated by msfvenom LHOST=...),
        // we replace the string bytes.

        // Helper to convert string to byte array
        const strToBytes = (str) => {
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                bytes.push(str.charCodeAt(i));
            }
            return bytes;
        };

        const placeholderIpBytes = strToBytes(placeholderIp);
        const newIpBytes = strToBytes(newIp);

        // Validation: New IP must not be longer than placeholder
        if (newIpBytes.length > placeholderIpBytes.length) {
            throw new Error(`New IP (${newIp}) is longer than placeholder (${placeholderIp}). Cannot patch safely.`);
        }

        // Pad new IP with null bytes (0x00) or spaces (0x20) if shorter?
        // Usually for shellcode strings, null termination is key, but sometimes it's just a buffer.
        // Safest approach for msfvenom templates: 
        // If the placeholder was "111.111.111.111" (15 chars), and we write "10.0.0.1" (8 chars),
        // we should probably write "10.0.0.1" followed by null bytes to fill the space, 
        // OR just write it and leave the rest if it was null-terminated.
        // However, if we are replacing a string in the data section, we should match the length to avoid shifting offsets (which would break the binary).
        // BUT, we can't shift offsets in a compiled binary easily.
        // SO: We MUST maintain exact length if we want to be 100% safe, OR we assume the placeholder is in a null-terminated string buffer.
        // Let's try to find the exact sequence of the placeholder.

        let ipMatches = 0;
        for (let i = 0; i < data.length - placeholderIpBytes.length; i++) {
            let match = true;
            for (let j = 0; j < placeholderIpBytes.length; j++) {
                if (data[i + j] !== placeholderIpBytes[j]) {
                    match = false;
                    break;
                }
            }

            if (match) {
                console.log(`[Patcher] Found IP placeholder at offset ${i}`);
                // Overwrite
                for (let k = 0; k < placeholderIpBytes.length; k++) {
                    if (k < newIpBytes.length) {
                        data[i + k] = newIpBytes[k];
                    } else {
                        // Fill remaining space with NULL bytes (0x00) to terminate the string early
                        data[i + k] = 0x00;
                    }
                }
                ipMatches++;
            }
        }

        // 2. Patch Port
        // Ports in binaries can be strings ("4444") or integers (little-endian or big-endian).
        // msfvenom usually embeds the port as a big-endian integer (network byte order) in the shellcode,
        // OR as a string if it's a script/stage.
        // Since we are targeting a generic "Template", we will try to patch BOTH string and integer representations to be safe.

        // A. String Patch ("4444" -> "8080")
        const oldPortBytes = strToBytes(oldPort.toString());
        const newPortBytes = strToBytes(newPort.toString());

        if (newPortBytes.length <= oldPortBytes.length) {
            for (let i = 0; i < data.length - oldPortBytes.length; i++) {
                let match = true;
                for (let j = 0; j < oldPortBytes.length; j++) {
                    if (data[i + j] !== oldPortBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    console.log(`[Patcher] Found Port String at offset ${i}`);
                    for (let k = 0; k < oldPortBytes.length; k++) {
                        if (k < newPortBytes.length) {
                            data[i + k] = newPortBytes[k];
                        } else {
                            data[i + k] = 0x00;
                        }
                    }
                }
            }
        }

        // B. Integer Patch (Network Byte Order / Big Endian) - Common in shellcode
        // Port 4444 = 0x115C. In Big Endian: 11 5C. Little Endian: 5C 11.
        const oldPortInt = parseInt(oldPort);
        const newPortInt = parseInt(newPort);

        // Helper for 16-bit matching
        const patchInt16 = (valOld, valNew) => {
            const oldHi = (valOld >> 8) & 0xFF;
            const oldLo = valOld & 0xFF;
            const newHi = (valNew >> 8) & 0xFF;
            const newLo = valNew & 0xFF;

            // Big Endian Scan
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i] === oldHi && data[i + 1] === oldLo) {
                    // Check if it looks like a port instruction (often preceded by specific opcodes, but let's be aggressive for now or just hope 0x115C isn't common data)
                    // 4444 (0x115C) is fairly unique.
                    console.log(`[Patcher] Found Port Int (BE) at offset ${i}`);
                    data[i] = newHi;
                    data[i + 1] = newLo;
                }
            }

            // Little Endian Scan (less likely for network ports in shellcode, but possible in config structs)
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i] === oldLo && data[i + 1] === oldHi) {
                    console.log(`[Patcher] Found Port Int (LE) at offset ${i}`);
                    data[i] = newLo;
                    data[i + 1] = newHi;
                }
            }
        };

        patchInt16(oldPortInt, newPortInt);

        if (ipMatches === 0) {
            console.warn("[Patcher] WARNING: No IP placeholders found!");
            // We don't throw error, maybe they only wanted to patch port?
            // But usually this means the template is wrong.
        }

        return new Blob([data], { type: "application/octet-stream" });
    }
};
